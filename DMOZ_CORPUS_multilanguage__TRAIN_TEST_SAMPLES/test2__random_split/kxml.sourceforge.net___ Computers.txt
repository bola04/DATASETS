<html>
  <head>
   <title>
    kXML
   </title>
   <link href="kobjects.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
   <div class="title">
    kXML
   </div>
   <div class="kobjects">
    <a href="http://kobjects.org">
     kObjects.org:
    </a>
   </div>
   <div class="toc">
    <a href="#android">
     kXML on Android
    </a>
    |
    <a href="#about">
     About
    </a>
    |
    <a href="javadoc/index.html">
     JavaDoc
    </a>
    |
    <a href="https://github.com/stefanhaustein/kxml2">
     GitHub Project
    </a>
   </div>
   <h1 id="github">
    Moving to GitHub
   </h1>
   The new project location is: https://github.com/stefanhaustein/kxml2
   <h1 id="android">
    kXML on Android
   </h1>
   <p>
    kXML2 (or a compatible XML pull parser) should be available on all Android devices.
 Obtain a parser using this code fragment:
   </p>
   <pre>
 XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
 XmlPullParser parser = factory.newPullParser();
 </pre>
   <h1 id="about">
    About kXML
   </h1>
   <p>
    kXML is a small XML pull parser, specially designed for constrained environments such as Applets, Personal Java or MIDP devices. In contrast to kXML 1, kXML 2 is based on the
    <a href="http://xmlpull.org">
     common 
 XML pull API
    </a>
    .
   </p>
   <p>
    Pull based XML parsing combines some of the advantages of SAX and DOM:
   </p>
   <ul>
    <li>
     In contrast to push parsers (SAX), pull parsers such as kXML make it possible to model the
 XML processing routines after the structure of the processed XML document. Events processing
 is similar to an InputStream. If a part of the stream requires special handling, the parser 
 can simply be delegated to a specialized method by handing over the parser.
    </li>
    <li>
     While the above is also possible with an explicit DOM, DOM usually requires that the whole
 document structure is present in main memory.
    </li>
    <li>
     In contrast to DOM based parsing, the XML events are accessible immediately when they
 are available, it is not necessary to wait for the whole tree to build up.
    </li>
   </ul>
   <h2>
    kXML History and Versions
   </h2>
   <table border="1">
    <tr>
     <td valign="top">
      XP
     </td>
     <td valign="top">
      XP was the predecessor of kXML, a simple wrapper that turned a given SAX parser 
        into a pull parser.
        XP was originally implemented to simplify message (de)serialization in the Infolayer project,
        which is quite cumbersome with push parsers (SAX).
     </td>
    </tr>
    <tr>
     <td valign="top">
      kXML1
     </td>
     <td valign="top">
      To use the pull parser on embedded devices, it was necessary to get
        rid of the SAX dependency. kXML1 is a simple pull parser, based on event objects. 
        kXML1 is now deprecated, please use kXML2 instead. kXML1 is archieved at
      <a href="http://kxml.objectweb.org">
       kxml.objectweb.org
      </a>
      .
     </td>
    </tr>
    <tr>
     <td valign="top">
      kXML2
     </td>
     <td valign="top">
      The current version of kXML. In contrast to kXML1, it features cursor
        API instead of event objects, leading to a reduced footprint and less object
        creation overhead. kXML 2 is released under the BSD license.
     </td>
    </tr>
   </table>
   <h2>
    Special Features
   </h2>
   <p>
    kXML has two "special" features that are intended to simplify developers' life in constrained environments:
   </p>
   <ul>
    <li>
     Support for
     <em>
      WBXML
     </em>
     (WAP binary encoded XML): Allows to parse WAP or Wireless Village content
    </li>
    <li>
     A robust
     <em>
      "relaxed" mode
     </em>
     for parsing HTML or SGML files (that are not well-formed XML documents) in order to avoid 
  the need of two separate parsers in mobile phones.
    </li>
   </ul>
   <h2>
    XML Conformance
   </h2>
   <p>
    In order to keep kXML as small as possible, no efforts are made to recognize certain well-formedness errors that would require additional detection code, such as
   </p>
   <ul>
    <li>
     ']]&gt;' contained in text content,
    </li>
    <li>
     duplicate attributes, and
    </li>
    <li>
     &lt;? folowed by a space before the target.
    </li>
   </ul>
   <p>
    Thus, kXML will accept some XML documents that should actually be rejected. Of course, an XML parser should detect all syntax errors to discourage the creation of bogous documents that work with one parser and do not work with another. Thus, if you are not limited by memory constraints, please use
    <a href="http://www.extreme.indiana.edu/xgws/xsoap/xpp/mxp1/">
     MXP
    </a>
    , which is also faster than kXML.
   </p>
   <h2>
    Recommended Calling Conventions
   </h2>
   When handing an XMLpull parser to subroutines, it is recommended that the current 
 position is on a start tag (allowing the subroutine to analyze the attributes). 
 The post condition should usually be that the current position is the matching end tag.
   <h2>
    Parsing Element-Only and Text-Only Content
   </h2>
   <p>
    General XML content can be parsed with the XML pull API using a loop advanving
 to the next event and a switch statement that depends on the event type. However, 
 when using XML for data transfer (in contrast to text documents), most XML elements 
 contain either only text or only other elements (possibly with further sub-elements). 
 For those common cases, the parsing process can be simplified significantly by
 using the XmlPull API methods
    <em>
     nextTag
    </em>
    and
    <em>
     nextText
    </em>
    . 
 
 Additionally, the method
    <em>
     require()
    </em>
    may optionally be used to assert a 
 certain parser state.  The following sample illustrates both situations and methods. 
 The outer element
    <em>
     elements
    </em>
    has element-only content; the contained
    <em>
     text
    </em>
    -elements have text-only content:
   </p>
   <pre>
 &lt;elements&gt;
   &lt;text&gt;text1&lt;/text&gt;
   &lt;text&gt;text2&lt;/text&gt;
 &lt;/elements&gt;  
 </pre>
   <p>
    Parsing Code
   </p>
   <pre>
 parser.nextTag();
 parser.require(XmlPullParser.START_TAG, null, "elements");
 
 while(parser.nextTag() == XmlPullParser.START_TAG) {
   parser.require(XmlPullParser.START_TAG, null, "text");
 
    // handle element content
    System.out.println("text content: "+ parser.nextText());
 
   parser.require(XmlPullParser.END_TAG, null, "text");
 }
 
 parser.require(XmlPullParser.END_TAG, null, "elements");
 </pre>
   <p>
    <em>
     nextTag()
    </em>
    advances to the next 
 start or end tag, skipping insignificant events such as white space, 
 comments and PIs.
    <em>
     nextText()
    </em>
    requires that the current position 
 is a start tag. It returns the text content of the corresponding element. 
 The post condition is that the current position is an end tag.
 Please note that the calls
    <em>
     require()
    </em>
    are optional assertions, 
 they may be left out completely.
   </p>
  </body>
 </html>
